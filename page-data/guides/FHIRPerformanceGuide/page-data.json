{"componentChunkName":"component---src-pages-guides-fhir-performance-guide-md","path":"/guides/FHIRPerformanceGuide/","result":{"pageContext":{"frontmatter":{"layout":"post","title":"IBM FHIR Server Performance Guide","description":"IBM FHIR Server Performance Guide","Copyright":"years 2020","lastupdated":"2020-12-02","permalink":"/FHIRServerPerformanceGuide/"},"relativePagePath":"/guides/FHIRPerformanceGuide.md","titleType":"append","MdxNode":{"id":"b6edf3a3-94dd-59b2-8cef-1e87a9a55c1b","children":[],"parent":"7d5ad5ab-cdf6-577f-9c37-bda49c674ab9","internal":{"content":"---\nlayout: post\ntitle:  IBM FHIR Server Performance Guide\ndescription: IBM FHIR Server Performance Guide\nCopyright: years 2020\nlastupdated: \"2020-12-02\"\npermalink: /FHIRServerPerformanceGuide/\n---\n\n- [1 Overview](#1-overview)\n- [2 System Sizing](#2-system-sizing)\n- [3 FHIR Server Configuration](#3-fhir-server-configuration)\n  * [3.1 Concurrency](#31-concurrency)\n  * [3.2 Transaction Timeout](#32-transaction-timeout)\n  * [3.3 Session Affinity](#33-session-affinity)\n  * [3.4 Valud-Id Caches](#34-value-id-caches)\n  * [3.5 Logical Id Generation](#35-logical-id-generation)\n  * [3.6 Compartment Search Optimization](#36-compartment-search-optimization)\n- [4 Database Tuning](#4-database-tuning)\n  * [4.1 PostgreSQL](#41-postgresql)\n  * [4.2 IBM Db2](#42-ibm-db2)\n  * [4.3 Derby](#43-derby)\n- [5 Client Access Scenarios](#5-client-access-scenarios)\n  * [5.1 Search Examples](#51-search-examples)\n- [6 Tools](#6-tools)\n  * [6.1 Making FHIR Requests With curl](#61-making-fhir-requests-with-curl)\n  * [6.2 Making FHIR Requests with IBM FHIR Server Client](#62-making-fhir-requests-with-ibm-fhir-server-client)\n\n# 1 Overview\n\nThis guide describes how to tune IBM FHIR Server and its database to get the best performance. It also describes different FHIR query strategies which may help to work around specific performance issues.\n\nNote: all logical-ids and resources in this guide are examples and do not refer to actual patient data.\n\n# 2 System Sizing\n\nThe sizing table below should be considered a starting point. Actual requirements may vary greatly based on the specific scenarios for a given deployment. For example, search-heavy workloads will require more database CPU and IOPS capacity than a system servicing simple reads.\n\nCPU consumption of the IBM FHIR Server is closely correlated with the number of resources being processed, particularly during ingestion where processing involves:\n\n* Parsing\n* Validation\n* Search Parameter Evaluation\n* Persistence\n\nThe following sizes are guidelines only. You should test and measure for your specific use-cases.\n\n**Data Volume and Load Examples**\n\n| T-Shirt Size | Patient Lives | Searches/s | Resource reads/s | Resource writes/s | Daily New Resources |\n| ------------ | ------------- | ---------- | ---------------- | ----------------- | ------------------- |\n| Small (S)    |     3,000,000 |         10 |              350 |               100 |           1,440,000 |\n| Medium (M)   |    10,000,000 |         20 |              900 |               300 |           4,320,000 |\n| Large (L)    |    35,000,000 |         70 |            3,500 |             1,100 |          15,840,000 |\n\n<br/>\n\n**Example System Sizing**\n\n| T-Shirt Size | Server Nodes | Server Cores | Server GB | DB Cores | DB GB | IOPS | Total Cores | Total GB |\n| ------------ | ------------ | ------------ | --------- | -------- | ----- | ---- | ----------- | -------- |\n| Small (S)    |            2 |            2 |         4 |        4 |     8 |   3K |           8 |       16 |\n| Medium (M)   |            4 |            4 |         8 |        8 |    16 |  10K |          24 |       48 |\n| Large (L)    |            6 |            8 |         8 |       24 |    64 |  35K |          72 |      112 |\n\n<br/>\n\n**Note and Assumptions:**\n\n1. Resource ingestion limited to a 4 hour window;\n2. Resource reads/second represents total from all read, vread, history and search requests;\n3. Searches and reads mostly occur during the business day, leaving capacity for maintenance tasks and new resource ingestion during off-peak hours;\n4. Average resource size is 2KiB.\n\n<br/>\n\n# 3 FHIR Server Configuration\n\nTerminology:\n* **tenant_name** - the name/id of a tenant. Used interchangeably with tenant_id;\n* **tenant_id** - the name/id of a tenant. Used interchangeably with tenant_name;\n* **tenant_key** - a password fragment used in Db2 to verify tenant access ;\n* **datastore** - represents a logical database used by the persistence layer to store/retrieve FHIR resources;\n* **datasource** - the JTA object from which the persistence layer code can obtain JDBC connections to the underlying database. A datastore may include multiple datasource definitions used for different purposes;\n* **ds-id** - an identifier representing a datastore used for a tenant.\n\n\n## 3.1 Concurrency\n\nThis section describes how to configure the IBM FHIR Server and its database for concurrency.\n\n### 3.1.1 Liberty Profile Concurrency\n\nLiberty Profile uses an executor service to handle incoming HTTP/S requests. By default, the executor service automatically adjusts its thread pool size to most efficiently handle the request load. Although the executor service can be configured, we recommend using the default configuration. The best solution for supporting greater concurrency is to scale-out additional instances of the IBM FHIR Server.\n\n### 3.1.2 Database Max Connections\n\nDb2 and PostgreSQL limit the maximum number of open connections. It is important to configure the database in conjunction with the Liberty Profile datasource connection pools to avoid connection failures which will result in HTTP 500 errors being returned from the IBM FHIR Server.\n\nAssuming there are N instances of the IBM FHIR Server, the recommended connection limits should be configured as follows:\n\n\n| Database     |          Property Name          | Recommended Setting  |\n| ------------ | ------------------------------- | -------------------- |\n| IBM Db2      | MAX_CONNECTIONS/MAX_COORDAGENTS | maxPoolSize * N + 20 |\n| PostgreSQL   |                 max_connections | maxPoolSize * N + 15 |\n| Derby        |                             N/A |                  N/A |\n\n\nSee [Managing PostgreSQL Connections](https://cloud.ibm.com/docs/databases-for-postgresql?topic=databases-for-postgresql-managing-connections) in the IBM Cloud documentation for more information.\n\n### 3.1.3 JEE Datasource (Default, Recommended)\n\nThe recommended approach for tenant datatstore configuration is to use individual JTA datasources, each with their own connection manager (connection pool):\n\n```\n    <dataSource id=\"fhirDatasourcePGCloudDefault\" jndiName=\"jdbc/fhir_tenant1_default\" type=\"javax.sql.XADataSource\" statementCacheSize=\"200\" syncQueryTimeoutWithTransactionTimeout=\"true\" validationTimeout=\"30s\">\n        <jdbcDriver javax.sql.XADataSource=\"org.postgresql.xa.PGXADataSource\" libraryRef=\"sharedLibPostgres\"/>\n            <properties.postgresql\n                 serverName=\"your.postgres.host\"\n                 portNumber=\"5432\"\n                 databaseName=\"fhirdb\"\n                 user=\"fhirserver\"\n                 password=\"change-password\"\n                 currentSchema=\"fhirdata\"\n                 ssl=\"true\"\n                 sslmode=\"require\"\n                 sslrootcert=\"resources/security/your-postgres-host.crt\" />\n        />\n        <connectionManager maxPoolSize=\"200\" minPoolSize=\"20\" connectionTimeout=\"60s\" maxIdleTime=\"2m\" numConnectionsPerThreadLocal=\"2\"/>\n    </dataSource>\n```\n\nBecause each datasource gets its own connection manager you can tune each independently. If multiple datasources point to the same database (for example using different schemas to support multi-tenancy) be sure to configure the database `max_connections` accordingly. Also, remember to sum the maxPoolSize for all datasources across all IBM FHIR Server nodes in your deployment.\n\nEach JTA datasource should be configured in its own `.xml` server configuration file and placed into `{fhir-server-home}/configDropins/overrides` where it will be picked up automatically by Liberty Profile on startup.\n\n### 3.1.4 Proxy Datasource (Legacy)\n\nThe IBM FHIR Server proxy datasource is based on a custom datasource implementation which allows datasources to be programmatically added and removed without a server restart, something not supported natively in Liberty Profile. This implementation has been deprecated and is no longer the default configuration.\n\nTo use the IBM FHIR Server proxy datasource, just one Liberty Profile JTA `<dataSource>` is required:\n\n```\n    <dataSource id=\"fhirProxyDataSource\" jndiName=\"jdbc/fhirProxyDataSource\" type=\"javax.sql.XADataSource\" statementCacheSize=\"200\" syncQueryTimeoutWithTransactionTimeout=\"true\" validationTimeout=\"30s\">\n        <jdbcDriver libraryRef=\"fhirSharedLib\" javax.sql.XADataSource=\"com.ibm.fhir.persistence.proxy.FHIRProxyXADataSource\"/>\n        <connectionManager maxPoolSize=\"200\" minPoolSize=\"20\" connectionTimeout=\"60s\" maxIdleTime=\"2m\" numConnectionsPerThreadLocal=\"2\"/>\n    </dataSource>\n```\n\nOnly one connection pool is supported, as defined by the `<connectionManager>` element. The `max_connections` for each target database should be configured to be `maxPoolSize` times the cluster size plus the overhead recommended for the given database type to support basic operation and monitoring etc.\n\nNote, the FHIRProxyXADataSource is only called to provide new connections. Most `getConnection()` requests will be served directly by the connection pool.\n\n\n| Property | Recommended Value | Description |\n| -------- | ----------------- | ----------------------------------------------------------- |\n| statementCacheSize | 200 | The number of prepared statements cached per connection. |\n| jndiName | jdbc/fhirProxyDataSource | The JNDI address used by the IBM FHIR Server code to locate the datasource |\n| type | javax.sql.XADataSource | The Java interface representing the datasource, implemented by FHIRProxyXADataSource |\n| javax.sql.XADataSource | com.ibm.fhir.persistence.proxy.FHIRProxyXADataSource | The IBM FHIR Server custom datasource implementation |\n| libraryRef | fhirSharedLib | Liberty Profile shared library definition referencing the Jar files containing the FHIRProxyXADataSource implementation. |\n| maxPoolSize | see below | The max number of connections allowed |\n| minPoolSize | 40 | The pool will shrink to this size by aging out old connections |\n| connectionTimeout | 60s | Timeout when trying to establish a new connection to the database |\n| maxIdleTime | 2m | Removes connections from the pool when they are unused for this amount of time, but does not shrink the pool below minPoolSize |\n| numConnectionsPerThreadLocal | 2 | Number of connections cached in thread-local storage. Testing has shown the value 2 is sufficient to eliminate contention in high-concurrency scenarios. |\n\n\n\n## 3.2 Transaction Timeout\n\nLong transactions consume significant resources so to protect the system, Liberty Profile will time-out a transaction after 2 minutes (120s) by default. When a transaction times out, Liberty Profile will forcibly close any database connection currently executing a statement and the IBM FHIR Server will return an HTTP 500 response to the caller. The maximum transaction time can be extended using the `<transaction>` element in the Liberty Profile configuration. See Database Access TransactionManager Timeout in the (IBM FHIR Server User's Guide)[https://ibm.github.io/FHIR/guides/FHIRServerUsersGuide/] for a description how to configure this in the IBM FHIR Server.\n\nThe following table summarizes how the transaction timeout is used for different request types:\n\n| Request Type | Transaction Scope and Usage |\n| ------------------ | ------------------------------------------------------------ |\n| READ               | Single transaction scope for entire request |\n| VREAD              | Single transaction scope for entire request |\n| HISTORY READ       | Single transaction scope for entire request |\n| SEARCH             | Single transaction scope for entire request |\n| POST/PUT           | Single transaction scope for entire request |\n| Batch Bundle       | Transaction per bundle entry. Request processing time can therefore exceed totalTranLifetimeTimeout |\n| Transaction Bundle | Single transaction scope for entire request |\n| $reindex           | One HTTP call can request multiple resources to be reindexed. Each resource is reindexed in the scope of its own transaction. Reindexing is a relatively quick operation per resource - usually well under 1s - so transaction timeouts are unlikely. Reduce the number of resources processed per reindex operation to avoid read timeouts. Use concurrent requests to increase overall throughput. |\n\nBecause some requests use multiple transactions under the covers, the overall request response time can sometimes be greater than the transaction timeout. There is no server-side tuneable property for the overall request processing time. Tuning of the client read timeout and/or network configuration may be required when extending the maximum transaction time to more than 2 minutes, or supporting multi-transaction requests which also exceed 2 minutes.\n\nFirewalls or other components in the flow between a client and the IBM FHIR Server may forcibly close (reset) a connection which is considered idle. This is usually because no packets associated with the TCP connection will flow between the client and the IBM FHIR Server until the response is returned. There are two ways to address this:\n\n1. Configure the network path to make sure that TCP idle timeout exceeds the client read timeout for all components in the client-server flow. This is impractical unless the infrastructure is dedicated (e.g. an internal system-to-system flow), even then it might not be desirable or allowed;\n2. Configure TCP keep-alive (SO_KEEPALIVE) on the connection. This instructs the operating system to occassionally send packets over the wire to let the networking components know that the connection is still active while the client waits for a response from the server. Some clients may configure keep-alive by default, in which case no action is required. Note that TCP keep-alive should not be confused with HTTP Keep-Alive. The TCP keep-alive and client read-timeout values should be considered together. There is no point configuring TCP keep-alive if the delay before sending the first packet is longer than the client read-timeout. Likewise, TCP keep-alive will not prevent a client read from timing out. TCP keep-alive only ensures a connection is not reset by a network component thinking it is idle. The timing values you configure need to be guided by the network configuration in your particular solution.\n\n## 3.3 Session Affinity\n\nTLS connection setup is a costly CPU operation. It is therefore important to ensure that routing components are configured for session affinity to avoid unnecessary connection setup costs. Clients should be written to reuse connections when making multiple requests.\n\n## 3.4 Value-Id Caches\n\nThe IBM FHIR Server uses internal memory caches for resource type names, parameter names, references, codes and systems. These caches use a least-recently-used (LRU) strategy to avoid unbound growth which would result in an out-of-memory (OOM) condition.\n\nCurrently the IBM FHIR Servers do not use sharding(*) to distribute client requests and so any client request may hit any server in a given cluster. This means that the memory used for caching value-id lookups is not distributed, but each servers' cache is complete and may contain data also cached in another server. This may be revised in future releases if it becomes a scaling issue.\n\n(*) - sharding is really the responsibility of the component used to route requests to the IBM FHIR Servers, and if such a component were to support sharding, it would help to reduce the cache pressure by distributing values among the available cache instances.\n\nThe following datasource properties in fhir-server-config.json are used to tune the size of the value-id caches:\n\n\n| Property                | Default Value | Units           | Description |\n| ----------------------- | ------------- | --------------- | ----------- |\n| externalSystemCacheSize |          1000 | Number of items | Size of the LRU cache used to hold unique code-system values. Per tenant/datastore. |\n| externalValueCacheSize  |        100000 | Number of items | Size of the LRU cache used to hold unique token values. Per tenant/datastore. |\n\n\nThe caches are isolated by tenant and specific to each datasource defined for that tenant:\n\n```\n{\n    \"fhirServer\": {\n        \"persistence\": {\n            \"factoryClassname\": \"com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCFactory\",\n            \"common\": {\n                \"__comment\": \"Configuration properties common to all persistence layer implementations\",\n                \"updateCreateEnabled\": true\n            },\n            \"jdbc\": {\n                ...\n                \"enableCodeSystemsCache\": true,\n                \"enableParameterNamesCache\": true,\n                \"enableResourceTypesCache\": true\n            },\n            \"datasources\": {\n                \"default\": {\n                    \"jndiName\": \"jdbc/bootstrap_default_default\",\n                    \"type\": \"derby\",\n                    \"currentSchema\": \"APP\",\n                    \"externalSystemCacheSize\": 1000,\n                    \"externalValueCacheSize\": 100000\n                },\n                ...\n            }\n        }\n    }\n}\n```\n\nCurrently no cache-hit metrics are exposed related to the caches. Tuning relies on Application Performance Management (APM) profiling and monitoring database activity looking for frequent value-id lookups against the following tables:\n\n* PARAMETER_NAMES\n* RESOURCE_TYPES\n* COMMON_TOKEN_VALUES\n* CODE_SYSTEMS\n\nThe values for PARAMETER_NAMES and RESOURCE_TYPES are supposed to be fully cached. Any substantial reads (selects) from these tables after initial startup/first request should be considered a defect.\n\n## 3.5 Logical Id Generation\n\nUsing random values for resource identifiers can cause performance issues in large databases. This is a particular issue when using PostgreSQL with the IBM FHIR Server due to an issue known as write amplification from full page writes. For details, see this blog post: https://www.2ndquadrant.com/en/blog/on-the-impact-of-full-page-writes.\n\nFor best performance, ids generated by clients should not be purely random but instead be structured to include a prefix which increments over time. This causes index entries for new values to share pages (right-hand inserts), greatly reducing the write amplification overhead.\n\nOne example of a suitable id generation strategy can be found in the [IBM FHIR Server fhir-persistence-jdbc project](https://github.com/IBM/FHIR/blob/main/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/TimestampPrefixedUUID.java).\n\nThis strategy provides both the desirable trait of global uniqueness as well as a low write amplification overhead thanks to the time-based prefix.\n\nThe IBM FHIR Server also uses normalization to avoid storing (and indexing) long identifier strings in multiple places. This saves space, and the database-generated identity values are based on sequences which naturally produce the desired right-hand-insert behavior.\n\n## 3.6 Compartment Search Optimization\n\nResources are assigned to various compartments using expressions with multiple terms. In the IBM FHIR Server JDBC persistence layer, these expressions are translated to SQL predicates with multiple `OR` statements. These `ORs` make it more difficult for the query optimizer to compute the most efficient execution plan resulting in a slow query. To address this, the IBM FHIR Server evaluates the compartment membership expression during ingestion and stores the results. The SQL query can then be written using a single value predicate resulting in faster query.\n\nTo enable this optimization, set the `fhirServer/search/useStoredCompartmentParam` configuration parameter to `true` in the fhir-server-config.json file:\n\n```\n        \"search\": {\n            \"useStoredCompartmentParam\": true\n        },\n```\n\nEnabling this optimization is recommended. See the IBM FHIR Server release notes for more details.\n\n\n# 4 Database Tuning\n\n| Tuneable | Guidance |\n| -------- | -------- |\n| Caching  | Avoiding physical reads is important for most database applications and the IBM FHIR Server is no different. Memory sizing and configuration is important for good ingestion performance as well as good read performance. |\n| Statistics | Ensure statistics are up-to-date to allow the query optimizer to generate the best execution plans. |\n| Concurrency | Ensure the database supports the required number of connections from the application server cluster, plus any administration overhead. Connections and their associated sessions consume memory which must be considered in the overall database server memory budget. |\n\n\n## 4.1 PostgreSQL\n\nFor PostgreSQL, we recommend tuning the following properties:\n\n| Property | Recommendation | Description |\n| -------- | -------------- | ----------- |\n| max_connections | N+15 | N is the aggregate number of connections from the IBM FHIR Server cluster, defined by the connection manager's `maxPoolSize` property. Check the PostgreSQL documentation. Connections require memory, so be careful with large values which could lead to memory pressure on the database server causing performance issues or stability problems. |\n| shared_buffers | 1/2 of memory | The number of 8kB blocks used for caching table data. This is important for ingestion as well as query performance. The database must be able to find free blocks to hold table and index data it needs to modify when ingesting new data. |\n| effective_cache_size | 3/4 of memory | Number of 8kB blocks. Not an allocation, just provides guidance to the query optimizer for how much data it can expect to be cached by the database and operating system file system cache. It is used to bias decisions on choosing index-based access paths. IBM FHIR Server queries rely heavily on index-driven plans so this value should be at the upper end of any recommended range. |\n\nThe recommended values should be considered a starting point. Monitor database metrics and tune appropriately for your given workload. See the [PostgreSQL wiki](https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server) for additional guidance.\n\nFHIR search queries are translated into SQL expressions. When several search parameters are included in a request the resulting join spans many tables, several of which may be wrapped in views. In order to give the PostgreSQL query optimizer sufficient freedom to optimize the query, include the `searchOptimizerOptions` parameter map to the datasource configuration as shown below to increase the values for `from_collapse_limit` and `join_collapse_limit`. The default for both of these is 8. When there are more than 8 tables involved in the search query, the optimizer may not generate an efficient execution plan unless the limits are increased:\n\n```\n        \"persistence\": {\n            \"datasources\": {\n                \"default\": {\n                    \"type\": \"postgresql\",\n                    \"currentSchema\": \"fhirdata\",\n                    \"searchOptimizerOptions\": {\n                        \"from_collapse_limit\": 16,\n                        \"join_collapse_limit\": 16\n                    },\n                    ...\n```\n\nSee the [PostgreSQL Query Planning](https://www.postgresql.org/docs/12/runtime-config-query.html) guide for more information.\n\n### 4.1.1 Fillfactor\n\nIn PostgreSQL, the default `fillfactor` for each table is 100 - no room is reserved for updates. This maximizes storage utilization, but impacts performance for updates which occur when new versions of a resource are ingested. Update statements are also used frequently during the reindex process.\n\nTo provide space for updates, all the `<resourceType>_logical_resources` should be configured with a `fillfactor` of 80 as a starting point. DBAs may specify their own `fillfactor` values based on their own knowledge and understanding of the system.\n\nThe `fillfactor` for the `logical_resources` table may benefit from an even lower value to support the heavy update load during a reindex operation. This is a special case due to the fact that every row in the table is updated once.\n\nTo change the fillfactor for existing data, a `VACUUM FULL` operation is required:\n\n```\nALTER TABLE fhirdata.logical_resources SET (fillfactor=70);\n...\nVACUUM FULL fhirdata.logical_resources;\n```\n\nThis should only be performed during a maintenance window when there is no load on the system.\n\n### 4.1.2 Tuning Auto-vacuum\n\nWhen running reindex operations (after a search parameter configuration change, for example), the `logical_resources` table undergoes frequent updates to an indexed column. Due to the nature of how PostgreSQL handles updates, this results in a significant amount of old index blocks which slows progress. The table storage parameters may need to be tuned to vacuum the `logical_resources` table more aggressively. To address this, tune the storage parameters for this table as follows:\n\n```\n-- Lower the trigger threshold for starting work\nalter table fhirdata.logical_resources SET (autovacuum_vacuum_scale_factor = 0.01, autovacuum_vacuum_threshold=1000);\n\n-- Increase the amount of work vacuuming completes before taking a breather (default is typically 200)\nalter table fhirdata.logical_resources SET (autovacuum_vacuum_cost_limit=2000);\n```\n\nThe default value for autovacuum_vacuum_cost_limit is likely too restrictive for a system with good IO performance. Increasing the value to 2000 increases the throttling threshold 10x, significantly improving throughput and helping the `logical_resources` vacuuming to be completed before it negatively impacts reindexing performance.\n\nSee the [PostSQL VACUUM documentation](https://www.postgresql.org/docs/12/sql-vacuum.html) for more details.\n\nIn addition, administrators may also choose to run a manual vacuum as shown in the following example:\n\n```\nfhirdb=> VACUUM (ANALYZE,VERBOSE) fhirdata.logical_resources;\nINFO:  vacuuming \"fhirdata.logical_resources\"\nINFO:  scanned index \"logical_resources_pk\" to remove 16813312 row versions\nDETAIL:  CPU: user: 31.70 s, system: 14.30 s, elapsed: 75.38 s\n\nINFO:  scanned index \"unq_logical_resources\" to remove 16813312 row versions\nDETAIL:  CPU: user: 70.03 s, system: 56.69 s, elapsed: 232.57 s\nINFO:  scanned index \"idx_logical_resources_rits\" to remove 16813312 row versions\nDETAIL:  CPU: user: 11.42 s, system: 14.00 s, elapsed: 45.40 s\nINFO:  \"logical_resources\": removed 16813312 row versions in 355153 pages\nDETAIL:  CPU: user: 27.36 s, system: 12.08 s, elapsed: 67.53 s\nINFO:  index \"logical_resources_pk\" now contains 77504219 row versions in 544383 pages\nDETAIL:  16806938 index row versions were removed.\n0 index pages have been deleted, 0 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  index \"unq_logical_resources\" now contains 77504219 row versions in 2393179 pages\nDETAIL:  16805676 index row versions were removed.\n0 index pages have been deleted, 0 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  index \"idx_logical_resources_rits\" now contains 77504219 row versions in 775877 pages\nDETAIL:  16813298 index row versions were removed.\n507613 index pages have been deleted, 445589 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  \"logical_resources\": found 7765149 removable, 16804352 nonremovable row versions in 549284 out of 4210218 pages\nDETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 320896669\nThere were 21857963 unused item identifiers.\nSkipped 0 pages due to buffer pins, 3070111 frozen pages.\n46 pages are entirely empty.\nCPU: user: 206.67 s, system: 113.27 s, elapsed: 537.14 s.\nINFO:  analyzing \"fhirdata.logical_resources\"\nINFO:  \"logical_resources\": scanned 30000 of 4210218 pages, containing 551774 live rows and 0 dead rows; 30000 rows in sample, 77436294 estimated total rows\nVACUUM\n```\n\n### 4.1.3 Transaction Id Wraparound\n\nBe ware of multixact wraparound issues, as highlighted by the following warning when running a manual vacuum:\n\n```fhirdb=> VACUUM (VERBOSE) fhirdata.logical_resources;\nWARNING:  oldest multixact is far in the past\nHINT:  Close open transactions with multixacts soon to avoid wraparound problems.\n```\n\nThis indicates that the automatic vacuum process needs to be more aggressive. See [here](https://info.crunchydata.com/blog/managing-transaction-id-wraparound-in-postgresql) for details.\n\n\n### 4.1.4 Vacuum Monitoring\n\nUse the following query to see the impact of updates and deletes on the IBM FHIR Server tables (assuming the tenant is configured to use the `fhirdata` schema):\n\n```\n SELECT relname,\n        n_tup_ins AS \"inserts\",\n        n_tup_upd AS \"updates\",\n        n_tup_del AS \"deletes\",\n        n_live_tup AS \"live_tuples\",\n        n_dead_tup AS \"dead_tuples\"\n   FROM pg_stat_user_tables\n  WHERE schemaname = 'fhirdata'\n    AND (relname = 'logical_resources' OR relname LIKE '%_values')\n    AND n_dead_tup > 0;\n```\n\nThe values reported are since the database was last restarted. To check uptime, run the following query:\n\n```\n SELECT current_timestamp - pg_postmaster_start_time();\n    ?column?     \n-----------------\n 05:45:41.835965\n```\n\n\nThe following query can be used to see how many auto-vacuum jobs are currently in progress and for which tables:\n\n```\nfhirdb=> SELECT r.relname, v.*\n           FROM pg_stat_progress_vacuum v,\n                pg_stat_user_tables r\n          WHERE r.relid = v.relid;\n\n          relname          |  pid   | datid | datname | relid |       phase       | heap_blks_total | heap_blks_scanned | heap_blks_vacuumed | index_vacuum_count | max_dead_tuples | num_dead_tuples\n---------------------------+--------+-------+---------+-------+-------------------+-----------------+-------------------+--------------------+--------------------+-----------------+-----------------\n imagingstudy_token_values | 451383 | 16478 | fhirdb  | 45603 | vacuuming indexes |          332918 |            332918 |                  0 |                  0 |        96879138 |            5102\n condition_token_values    | 451793 | 16478 | fhirdb  | 52193 | scanning heap     |           53883 |             18173 |                  0 |                  0 |        15679953 |          301285\n logical_resources         | 451180 | 16478 | fhirdb  | 16533 | vacuuming indexes |         1432256 |           1432256 |                  0 |                  0 |       178956970 |          765313\n```\n\nBy default, only 3 vacuum jobs can run concurrently.\n\n### 4.1.5 Max Locks\n\nTo drop an IBM FHIR Server schema in PostgreSQL, set the following configuration in `postgresql.conf`:\n\n```\nmax_locks_per_transaction = 128\t\t# min 10\n```\n\nThis change requires a database restart.\n\n## 4.2 IBM Db2\n\nTBD.\n\n\n## 4.3 Derby\n\nDerby is not recommended for production use and therefore tuning Derby will not be addressed in this guide.\n\n\n# 5 Client Access Scenarios\n\nThe IBM FHIR Server translates a FHIR search request into a SQL query. The database performs query optimization to generate what it thinks is the most efficient execution plan before running the query. This optimization depends on the database having good statistics (and a clever algorithm) to make the right choice. When this goes wrong, the result is a slow response which can also end up consuming significant resources which impact the capacity of the system as a whole.\n\nThe FHIR search specification includes a rich set of capabilities designed to make it easier for clients to find data. If a particular search performs poorly, there are likely other ways the same data can be fetched. One solution is to use multiple requests, using FHIR bundle requests to request multiple resources in one server request.\n\nThere are many ways to retrieve data:\n\n* READ: read the latest version of a resource using its logical identifier. Fast.\n* VREAD: reads a specific version of a resource using its logical identifier and version. Fast.\n* SEARCH: id - fetch one resource matching the given logical id:\n* SEARCH: identity - fetch all resources matching the given identity. Usually one but could be multiple\n* SEARCH: last-modified - Find resources modified since a given date.\n* SEARCH: multiple attributes - find resources matching the search condition. Can be slow depending on the complexity of the resulting database query and the relative cardinality (row counts) of the resource search parameters.\n* SEARCH: include - fetch additional resources based on the relationships found in the resources returned by the main search criteria.\n* SEARCH - has\n* SEARCH - revinclude\n\nThere may also be some subtle semantic differences among searches which might appear to be equivalent. This is particularly true for compartment-based queries due to the complex definition of compartment membership defined in the FHIR specification.\n\n## 5.1 Read\n\nLogical id-based read requests are the fastest way to access a resource, for example:\n\n```\n    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\n```\n\nThis translates into a single query which utilizes indexes to quickly locate the required record:\n\n```\nSELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID,\n       R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID\n  FROM Patient_RESOURCES R,\n       Patient_LOGICAL_RESOURCES LR\n WHERE LR.LOGICAL_ID = ?\n   AND R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID\n```\n\nWhen the data is currently cached by the database, this query takes less than a millisecond to execute, as shown in the following execution plan analysis from PostgreSQL:\n\n```\nNested Loop  (cost=0.84..10.88 rows=1 width=1335) (actual time=0.046..0.058 rows=1 loops=1)\n  Buffers: shared hit=8\n  ->  Index Scan using idx_patient_logical_resourceslogical_id on patient_logical_resources lr  (cost=0.42..5.44 rows=1 width=53) (actual time=0.026..0.030 rows=1 loops=1)\n        Index Cond: ((logical_id)::text = '17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e'::text)\n        Buffers: shared hit=4\n  ->  Index Scan using patient_resources_prf_in1 on patient_resources r  (cost=0.42..5.44 rows=1 width=1290) (actual time=0.011..0.012 rows=1 loops=1)\n        Index Cond: (resource_id = lr.current_resource_id)\n        Buffers: shared hit=4\nPlanning Time: 0.313 ms\nExecution Time: 0.127 ms\n```\n\n## 5.2 Version Read\n\nThe FHIR specification supports reading a specific version of a resource:\n\n```\nPatient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/_history/1\n```\n\nThe resulting query is similar, except in this case, the specified version is requested from the PATIENT_RESOURCES table. Performance is similar to the plain read, depending on what data is currently cached, of course:\n\n```\nSELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID,\n       R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID\n  FROM Patient_RESOURCES R, Patient_LOGICAL_RESOURCES LR\n WHERE LR.LOGICAL_ID = ?\n   AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n   AND R.VERSION_ID = ?\n```\n\n## 5.3 History\n\nThe history query returns all versions of a resource. Because there is no limit to the number of versions for a given resource, the results are ordered by the version_id (resource version number) and paginated using OFFSET and FETCH NEXT ROWS clauses:\n\n```\n  SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID,\n         R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID\n    FROM Patient_RESOURCES R, Patient_LOGICAL_RESOURCES LR\n   WHERE LR.LOGICAL_ID = ?\n     AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\nORDER BY R.VERSION_ID DESC\n  OFFSET ? ROWS\n  FETCH NEXT ? ROWS ONLY\n```\n\nIn order to include an overall count of the number of resource versions, the IBM FHIR Server must execute an additional SQL query:\n\n```\nSELECT COUNT(R.VERSION_ID)\n  FROM Patient_RESOURCES R,\n       Patient_LOGICAL_RESOURCES LR\n WHERE LR.LOGICAL_ID = ?\n   AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID;\n```\n\nIn most cases the history queries will execute very quickly. Performance will be slower for cases where a single resource has thousands of versions. To avoid this, ingestion pipelines must ensure they only update a version when necessary.\n\n## 5.4 Search Performance\n\n**Predicate Order**\n\nThe IBM FHIR Server translates FHIR search queries into SQL statements which may require many tables to be joined. The database attempts to optimize the query execution plan by analyzing join conditions, filter predicates, available indexes and column statistics. The optimizer also attempts to order the joins in order to reduce the amount of work it must do. This usually involves computing the most selective clauses first. When there are many tables involved, the database optimizer may not always find the most efficient execution plan which can result in higher response times or `500` server errors if the total time exceeds the transaction timeout limit. For example, on a large database the following query may perform poorly if there are many ExplanationOfBenefit records with a Claim matching one of the given priorities:\n\n```\n/ExplanationOfBenefit?_pretty=true&claim.priority=normal,stat,deferred&_include=ExplanationOfBenefit:claim&_include=ExplanationOfBenefit:patient&patient:Patient.birthdate=le1915\n```\n\nThe above query requires a join of around 13 tables which is too many for the database to try all possible orders and so the most efficient plan is never tried. The IBM FHIR Server builds the SQL based on the order of filter predicates in the search request. This can be used along with knowledge of the data to place the most selective filter first which, in this case, is the patient `birthdate` range. Rewriting the query as follows can significantly improve the response time:\n\n```\n/ExplanationOfBenefit?_pretty=true&patient:Patient.birthdate=le1915&claim.priority=normal,stat,deferred&_include=ExplanationOfBenefit:claim&_include=ExplanationOfBenefit:patient\n```\n\n**Include Code System**\n\nToken-based searches should include a code-system when possible. The same code value might exist in multiple code-systems, Unless the code-system is included in the search query, the database join may need to consider multiple matches in order to find all the associated resources. This multiplies the amount of work the database must do to execute the query. This also impacts cardinality estimation by the optimizer. If both the code-system and code value are provided, this matches a unique index in the schema allowing the optimizer to infer the SQL fragment will produce a single row.\n\nDon't do this:\n```\nPatient/175517d8bea-32d33eec-d98f-4c99-a3cf-06a113ddcf08/CareTeam?status=active\n```\n\nInstead, do this:\n```\nPatient/175517d8bea-32d33eec-d98f-4c99-a3cf-06a113ddcf08/CareTeam?status=http://hl7.org/fhir/care-team-status|active\n```\n\nExplicitly providing the code is always preferred. If no system is provided, in some cases the IBM FHIR Server can determine the correct code-system to use automatically, which helps query performance.\n\n\n## 5.5 Search Examples\n\nThe section contains search examples and performance considerations for various types of search parameters.\n\n**STRING SEARCH**\nBecause the default behavior for string search has case-insensitive \"begins-with\" semantics, we encourage users to use the `:exact` modifier when possible for the best performance.\n\n**TOKEN SEARCH**\nHL7 FHIR supports a few variants of token search:\n* `[parameter]=[code]`\n* `[parameter]=[system]|[code]`\n* `[parameter]=|[code]`\n\nFor optimal performance, users should prefer the `[system]|[code]` variant.\n\nThis is especially important for code values that are common across systems (e.g short strings like \"active\").\nHowever, the IBM FHIR Server supports a SearchParameter extension which allows the server to add an implicit `[system]|` prefix for certain token parameter searches that come in with just a `[code]`.\n\nFor example, when a search parameter targets an element of type Code that has a required binding, there is typically a single implicit system for the code. In such cases, the IBM FHIR Server models these Code subtypes as Enums and the values are indexed with their implicit system. When the corresponding SearchParameter definition is decorated with the same implicit system (via this extension), it provides maximum specificity for the query to efficiently retrieve the token value.\n\nFor all such search parameters in the base spec, and first-class implementation guides that we package, we have taken the liberty to add these extensions a priori. For example, for `SearchParameter-Account-status`, the following extension tells the server to process a query like `Account?status=active` as if it were specified like `Account?status=http://hl7.org/fhir/audit-event-outcome|active`:\n```\n{\n    \"url\": \"http://ibm.com/fhir/extension/implicit-system\",\n    \"valueUri\": \"http://hl7.org/fhir/audit-event-outcome\"\n}\n```\n\n**COMPARTMENT SEARCHES**\n\nSearch for all ExplanationOfBenefit records which reference the patient according to its logical id `17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e`.\n\n```\n    <base>/ExplanationOfBenefit?patient=17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\n```\n\n\nSearch the patient compartment `17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e` for all matching ExplanationOfBenefit resources.\n\n```\n    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/ExplanationOfBenefit\n```\n\n**COMPARTMENT CHAINED SEARCH**\n\nRequests any ExplanationOfBenefit resources belonging to the compartment for patient `17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e` with a Claim created on a given day: 2015-10-16.\n\n```\n    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/ExplanationOfBenefit?claim:Claim.created=2015-10-16\n```\n\n**CLIENT SEARCH BUNDLES**\n\nIf the response time is not acceptable, an alternative strategy is to first fetch all the ExplanationOfBenefit resources associated with the given patient, then compose a second bundle request for the Claim records associated with the ExplanationOfBenefit resources returned by the first search. The initial request can fetch the Patient resource along with the ExplanationOfBenefit resources for that patient.\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"ExplanationOfBenefit?patient=17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\nNote the bundle type is specified as `transaction`. Because all the entries in the bundle are reads, there's no modification to the database and so no semantic difference between using `transaction` or `batch`. However, for `transaction`, the IBM FHIR Server initiates a single transaction for the entire request. In high load/concurrency conditions, this improves throughput.\n\nThe number of ExplanationOfBenefit resources for a given patient is likely to be relatively small. By iterating over the response to the previous request, the client can package a number of resource reads into one or more bundle requests. Read requests are the most efficient type of request for accessing data from the IBM FHIR Server.\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim/1747d7abed3-7f331c1b-5262-41b7-894a-09d63ddc1791\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7abe89-61ad12fd-61ba-4c06-9fbf-89a130babd27\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim/1747d7abf2d-bbfd621f-31ec-4044-88df-a5d14efba26a\"\n            }\n        },\n        ...\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7ac6b2-90d24ffc-b773-45c0-8194-a24057087c82\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\nAlthough this approach involves multiple requests to the IBM FHIR Server, the overall response time may be quicker due to the simplicity of the requests.\n\nThe client can filter the required Claim resources, or alternatively convert the reads to search requests:\n\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim?_id=1747d7abed3-7f331c1b-5262-41b7-894a-09d63ddc1791&created=2015-10-16\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7abe89-61ad12fd-61ba-4c06-9fbf-89a130babd27\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim?_id=1747d7abf2d-bbfd621f-31ec-4044-88df-a5d14efba26a&created=2015-10-16\"\n            }\n        },\n        ...\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7ac6b2-90d24ffc-b773-45c0-8194-a24057087c82\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\n**INCLUDE**\n\nAnother alternative which tends to perform well uses the `_include` function. The `_include` function is useful because it avoids the need for additional round-trips (the server performs the iteration internally).\n\nThis example retrieves ExplanationOfBenefit resources for patient `17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756` which were created between 2010 and 2020. The result bundle also includes the Patient, Provider, CareTeam and Coverage resources referenced by each matching ExplanationOfBenefit resource.\n\n```\n    <base>/ExplanationOfBenefit?patient=Patient/17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756&created=ge2010&created=lt2021&_include=ExplanationOfBenefit:patient&_include=ExplanationOfBenefit:provider&_include=ExplanationOfBenefit:care-team&_include=ExplanationOfBenefit:coverage\n```\n\n\n**REVINCLUDE**\n\nUsed when a client wants a particular resource and other resources pointing to it. For example, to retrieve a Patient resource and any Observations referring to that patient as the subject:\n\n```\n    <base>/Patient?_id=17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756&_revinclude=Observation.subject\n```\n\nFind all Observations matching the composite code-value-quantity value and for each such Observation, also return any DiagnosticReport referring to that Observation as the result:\n\n```\n    <base>/Observation?code-value-quantity=http://loinc.org|2339-0$69.1&_revinclude=DiagnosticReport:result\n```\n\nThe above query is likely to be expensive if the number of matching Observations is high. For better performance, consider constraining the search with additional predicates like the patient id.\n\n\n**LAST UPDATED**\n\nSearching for all resources updated on a single day is expensive:\n\n```\n    <base>?_lastUpdated=2020-10-31\n```\n\nIf possible, limit the search to a specific resource type. For example:\n\n```\n    <base>/Patient?_lastUpdated=2020-10-31\n```\n\nIf multiple resource types are of interest, consider packaging multiple search requests into a bundle:\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Patient?_lastUpdated=2020-10-31\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim?_lastUpdated=2020-10-31\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner?_lastUpdated=2020-10-31\"\n            }\n        },\n        ...\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"ExplanationOfBenefit?_lastUpdated=2020-10-31\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\n**RESOURCE SUBSETTING**\n\nHL7 FHIR defines return parameters `_summary` and `_elements` for requesting the server to subset the resources to be returned via search.\n\nThe IBM FHIR server implements such element filtering directly in its resource parser, meaning that the feature can save time in the parse as well as reducing the size of the response to the client.\n\nThis can provide significant savings for search requests that bring back lots of data (large pages and/or many field per resource).\n\n## 6 Tools\n\n## 6.1 Making FHIR Requests With curl\n\n```\ncurl -k -i \\\n-H 'Content-Type: application/json' \\\n-H 'X-FHIR-TENANT-ID: default' \\\n-u 'fhiruser:change-password' 'https://localhost:9443/fhir-server/api/v4/Practitioner/1749321b933-9fd77253-7fd4-47db-8ff8-9e4ccb21441d'\n```\n\nNote that the tenant header must match the tenant header defined in the fhir-server-config.json. The default tenant header is `X-FHIR-TENANT-ID`. If this header is not provided, the tenant value will be `default`.\n\nThe curl command can also be used to make POST calls to the IBM FHIR Server. This example creates a new Observation resource for the patient subject `abc123`:\n\n```\ncurl -k -i \\\n-H 'Content-Type: application/json' \\\n-H 'X-FHIR-TENANT-ID: default' \\\n-u 'fhiruser:change-password' 'https://localhost:9443/fhir-server/api/v4/Observation' -d '\n{\n    \"resourceType\": \"Observation\",\n    \"subject\": {\n        \"reference\": \"Patient/abc123\"\n    },\n    \"status\": \"final\",\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"363779003\",\n            \"display\": \"Genotype determination\"\n        }],\n        \"text\": \"Diplotype Call\"\n    },\n\"text\": {\n    \"status\": \"generated\",\n    \"div\": \"__redacted for brevity__\"\n  }\n}\n'\n```\n\nExamples of valid resources can be found in the [fhir-examples](https://github.com/IBM/FHIR/tree/main/fhir-examples) project.\n\n\n\n## 6.2 Making FHIR Requests with IBM FHIR Server Client\n\nSee FHIR client API in the [IBM FHIR Server User's Guide](https://ibm.github.io/FHIR/guides/FHIRServerUsersGuide).\n","type":"Mdx","contentDigest":"56cf3b769ad15f83180e8df8a8703d77","counter":112,"owner":"gatsby-plugin-mdx","fieldOwners":{"slug":"gatsby-plugin-slug"}},"frontmatter":{"title":"IBM FHIR Server Performance Guide","layout":"post","description":"IBM FHIR Server Performance Guide","Copyright":"years 2020","lastupdated":"2020-12-02","permalink":"/FHIRServerPerformanceGuide/"},"exports":{},"rawBody":"---\nlayout: post\ntitle:  IBM FHIR Server Performance Guide\ndescription: IBM FHIR Server Performance Guide\nCopyright: years 2020\nlastupdated: \"2020-12-02\"\npermalink: /FHIRServerPerformanceGuide/\n---\n\n- [1 Overview](#1-overview)\n- [2 System Sizing](#2-system-sizing)\n- [3 FHIR Server Configuration](#3-fhir-server-configuration)\n  * [3.1 Concurrency](#31-concurrency)\n  * [3.2 Transaction Timeout](#32-transaction-timeout)\n  * [3.3 Session Affinity](#33-session-affinity)\n  * [3.4 Valud-Id Caches](#34-value-id-caches)\n  * [3.5 Logical Id Generation](#35-logical-id-generation)\n  * [3.6 Compartment Search Optimization](#36-compartment-search-optimization)\n- [4 Database Tuning](#4-database-tuning)\n  * [4.1 PostgreSQL](#41-postgresql)\n  * [4.2 IBM Db2](#42-ibm-db2)\n  * [4.3 Derby](#43-derby)\n- [5 Client Access Scenarios](#5-client-access-scenarios)\n  * [5.1 Search Examples](#51-search-examples)\n- [6 Tools](#6-tools)\n  * [6.1 Making FHIR Requests With curl](#61-making-fhir-requests-with-curl)\n  * [6.2 Making FHIR Requests with IBM FHIR Server Client](#62-making-fhir-requests-with-ibm-fhir-server-client)\n\n# 1 Overview\n\nThis guide describes how to tune IBM FHIR Server and its database to get the best performance. It also describes different FHIR query strategies which may help to work around specific performance issues.\n\nNote: all logical-ids and resources in this guide are examples and do not refer to actual patient data.\n\n# 2 System Sizing\n\nThe sizing table below should be considered a starting point. Actual requirements may vary greatly based on the specific scenarios for a given deployment. For example, search-heavy workloads will require more database CPU and IOPS capacity than a system servicing simple reads.\n\nCPU consumption of the IBM FHIR Server is closely correlated with the number of resources being processed, particularly during ingestion where processing involves:\n\n* Parsing\n* Validation\n* Search Parameter Evaluation\n* Persistence\n\nThe following sizes are guidelines only. You should test and measure for your specific use-cases.\n\n**Data Volume and Load Examples**\n\n| T-Shirt Size | Patient Lives | Searches/s | Resource reads/s | Resource writes/s | Daily New Resources |\n| ------------ | ------------- | ---------- | ---------------- | ----------------- | ------------------- |\n| Small (S)    |     3,000,000 |         10 |              350 |               100 |           1,440,000 |\n| Medium (M)   |    10,000,000 |         20 |              900 |               300 |           4,320,000 |\n| Large (L)    |    35,000,000 |         70 |            3,500 |             1,100 |          15,840,000 |\n\n<br/>\n\n**Example System Sizing**\n\n| T-Shirt Size | Server Nodes | Server Cores | Server GB | DB Cores | DB GB | IOPS | Total Cores | Total GB |\n| ------------ | ------------ | ------------ | --------- | -------- | ----- | ---- | ----------- | -------- |\n| Small (S)    |            2 |            2 |         4 |        4 |     8 |   3K |           8 |       16 |\n| Medium (M)   |            4 |            4 |         8 |        8 |    16 |  10K |          24 |       48 |\n| Large (L)    |            6 |            8 |         8 |       24 |    64 |  35K |          72 |      112 |\n\n<br/>\n\n**Note and Assumptions:**\n\n1. Resource ingestion limited to a 4 hour window;\n2. Resource reads/second represents total from all read, vread, history and search requests;\n3. Searches and reads mostly occur during the business day, leaving capacity for maintenance tasks and new resource ingestion during off-peak hours;\n4. Average resource size is 2KiB.\n\n<br/>\n\n# 3 FHIR Server Configuration\n\nTerminology:\n* **tenant_name** - the name/id of a tenant. Used interchangeably with tenant_id;\n* **tenant_id** - the name/id of a tenant. Used interchangeably with tenant_name;\n* **tenant_key** - a password fragment used in Db2 to verify tenant access ;\n* **datastore** - represents a logical database used by the persistence layer to store/retrieve FHIR resources;\n* **datasource** - the JTA object from which the persistence layer code can obtain JDBC connections to the underlying database. A datastore may include multiple datasource definitions used for different purposes;\n* **ds-id** - an identifier representing a datastore used for a tenant.\n\n\n## 3.1 Concurrency\n\nThis section describes how to configure the IBM FHIR Server and its database for concurrency.\n\n### 3.1.1 Liberty Profile Concurrency\n\nLiberty Profile uses an executor service to handle incoming HTTP/S requests. By default, the executor service automatically adjusts its thread pool size to most efficiently handle the request load. Although the executor service can be configured, we recommend using the default configuration. The best solution for supporting greater concurrency is to scale-out additional instances of the IBM FHIR Server.\n\n### 3.1.2 Database Max Connections\n\nDb2 and PostgreSQL limit the maximum number of open connections. It is important to configure the database in conjunction with the Liberty Profile datasource connection pools to avoid connection failures which will result in HTTP 500 errors being returned from the IBM FHIR Server.\n\nAssuming there are N instances of the IBM FHIR Server, the recommended connection limits should be configured as follows:\n\n\n| Database     |          Property Name          | Recommended Setting  |\n| ------------ | ------------------------------- | -------------------- |\n| IBM Db2      | MAX_CONNECTIONS/MAX_COORDAGENTS | maxPoolSize * N + 20 |\n| PostgreSQL   |                 max_connections | maxPoolSize * N + 15 |\n| Derby        |                             N/A |                  N/A |\n\n\nSee [Managing PostgreSQL Connections](https://cloud.ibm.com/docs/databases-for-postgresql?topic=databases-for-postgresql-managing-connections) in the IBM Cloud documentation for more information.\n\n### 3.1.3 JEE Datasource (Default, Recommended)\n\nThe recommended approach for tenant datatstore configuration is to use individual JTA datasources, each with their own connection manager (connection pool):\n\n```\n    <dataSource id=\"fhirDatasourcePGCloudDefault\" jndiName=\"jdbc/fhir_tenant1_default\" type=\"javax.sql.XADataSource\" statementCacheSize=\"200\" syncQueryTimeoutWithTransactionTimeout=\"true\" validationTimeout=\"30s\">\n        <jdbcDriver javax.sql.XADataSource=\"org.postgresql.xa.PGXADataSource\" libraryRef=\"sharedLibPostgres\"/>\n            <properties.postgresql\n                 serverName=\"your.postgres.host\"\n                 portNumber=\"5432\"\n                 databaseName=\"fhirdb\"\n                 user=\"fhirserver\"\n                 password=\"change-password\"\n                 currentSchema=\"fhirdata\"\n                 ssl=\"true\"\n                 sslmode=\"require\"\n                 sslrootcert=\"resources/security/your-postgres-host.crt\" />\n        />\n        <connectionManager maxPoolSize=\"200\" minPoolSize=\"20\" connectionTimeout=\"60s\" maxIdleTime=\"2m\" numConnectionsPerThreadLocal=\"2\"/>\n    </dataSource>\n```\n\nBecause each datasource gets its own connection manager you can tune each independently. If multiple datasources point to the same database (for example using different schemas to support multi-tenancy) be sure to configure the database `max_connections` accordingly. Also, remember to sum the maxPoolSize for all datasources across all IBM FHIR Server nodes in your deployment.\n\nEach JTA datasource should be configured in its own `.xml` server configuration file and placed into `{fhir-server-home}/configDropins/overrides` where it will be picked up automatically by Liberty Profile on startup.\n\n### 3.1.4 Proxy Datasource (Legacy)\n\nThe IBM FHIR Server proxy datasource is based on a custom datasource implementation which allows datasources to be programmatically added and removed without a server restart, something not supported natively in Liberty Profile. This implementation has been deprecated and is no longer the default configuration.\n\nTo use the IBM FHIR Server proxy datasource, just one Liberty Profile JTA `<dataSource>` is required:\n\n```\n    <dataSource id=\"fhirProxyDataSource\" jndiName=\"jdbc/fhirProxyDataSource\" type=\"javax.sql.XADataSource\" statementCacheSize=\"200\" syncQueryTimeoutWithTransactionTimeout=\"true\" validationTimeout=\"30s\">\n        <jdbcDriver libraryRef=\"fhirSharedLib\" javax.sql.XADataSource=\"com.ibm.fhir.persistence.proxy.FHIRProxyXADataSource\"/>\n        <connectionManager maxPoolSize=\"200\" minPoolSize=\"20\" connectionTimeout=\"60s\" maxIdleTime=\"2m\" numConnectionsPerThreadLocal=\"2\"/>\n    </dataSource>\n```\n\nOnly one connection pool is supported, as defined by the `<connectionManager>` element. The `max_connections` for each target database should be configured to be `maxPoolSize` times the cluster size plus the overhead recommended for the given database type to support basic operation and monitoring etc.\n\nNote, the FHIRProxyXADataSource is only called to provide new connections. Most `getConnection()` requests will be served directly by the connection pool.\n\n\n| Property | Recommended Value | Description |\n| -------- | ----------------- | ----------------------------------------------------------- |\n| statementCacheSize | 200 | The number of prepared statements cached per connection. |\n| jndiName | jdbc/fhirProxyDataSource | The JNDI address used by the IBM FHIR Server code to locate the datasource |\n| type | javax.sql.XADataSource | The Java interface representing the datasource, implemented by FHIRProxyXADataSource |\n| javax.sql.XADataSource | com.ibm.fhir.persistence.proxy.FHIRProxyXADataSource | The IBM FHIR Server custom datasource implementation |\n| libraryRef | fhirSharedLib | Liberty Profile shared library definition referencing the Jar files containing the FHIRProxyXADataSource implementation. |\n| maxPoolSize | see below | The max number of connections allowed |\n| minPoolSize | 40 | The pool will shrink to this size by aging out old connections |\n| connectionTimeout | 60s | Timeout when trying to establish a new connection to the database |\n| maxIdleTime | 2m | Removes connections from the pool when they are unused for this amount of time, but does not shrink the pool below minPoolSize |\n| numConnectionsPerThreadLocal | 2 | Number of connections cached in thread-local storage. Testing has shown the value 2 is sufficient to eliminate contention in high-concurrency scenarios. |\n\n\n\n## 3.2 Transaction Timeout\n\nLong transactions consume significant resources so to protect the system, Liberty Profile will time-out a transaction after 2 minutes (120s) by default. When a transaction times out, Liberty Profile will forcibly close any database connection currently executing a statement and the IBM FHIR Server will return an HTTP 500 response to the caller. The maximum transaction time can be extended using the `<transaction>` element in the Liberty Profile configuration. See Database Access TransactionManager Timeout in the (IBM FHIR Server User's Guide)[https://ibm.github.io/FHIR/guides/FHIRServerUsersGuide/] for a description how to configure this in the IBM FHIR Server.\n\nThe following table summarizes how the transaction timeout is used for different request types:\n\n| Request Type | Transaction Scope and Usage |\n| ------------------ | ------------------------------------------------------------ |\n| READ               | Single transaction scope for entire request |\n| VREAD              | Single transaction scope for entire request |\n| HISTORY READ       | Single transaction scope for entire request |\n| SEARCH             | Single transaction scope for entire request |\n| POST/PUT           | Single transaction scope for entire request |\n| Batch Bundle       | Transaction per bundle entry. Request processing time can therefore exceed totalTranLifetimeTimeout |\n| Transaction Bundle | Single transaction scope for entire request |\n| $reindex           | One HTTP call can request multiple resources to be reindexed. Each resource is reindexed in the scope of its own transaction. Reindexing is a relatively quick operation per resource - usually well under 1s - so transaction timeouts are unlikely. Reduce the number of resources processed per reindex operation to avoid read timeouts. Use concurrent requests to increase overall throughput. |\n\nBecause some requests use multiple transactions under the covers, the overall request response time can sometimes be greater than the transaction timeout. There is no server-side tuneable property for the overall request processing time. Tuning of the client read timeout and/or network configuration may be required when extending the maximum transaction time to more than 2 minutes, or supporting multi-transaction requests which also exceed 2 minutes.\n\nFirewalls or other components in the flow between a client and the IBM FHIR Server may forcibly close (reset) a connection which is considered idle. This is usually because no packets associated with the TCP connection will flow between the client and the IBM FHIR Server until the response is returned. There are two ways to address this:\n\n1. Configure the network path to make sure that TCP idle timeout exceeds the client read timeout for all components in the client-server flow. This is impractical unless the infrastructure is dedicated (e.g. an internal system-to-system flow), even then it might not be desirable or allowed;\n2. Configure TCP keep-alive (SO_KEEPALIVE) on the connection. This instructs the operating system to occassionally send packets over the wire to let the networking components know that the connection is still active while the client waits for a response from the server. Some clients may configure keep-alive by default, in which case no action is required. Note that TCP keep-alive should not be confused with HTTP Keep-Alive. The TCP keep-alive and client read-timeout values should be considered together. There is no point configuring TCP keep-alive if the delay before sending the first packet is longer than the client read-timeout. Likewise, TCP keep-alive will not prevent a client read from timing out. TCP keep-alive only ensures a connection is not reset by a network component thinking it is idle. The timing values you configure need to be guided by the network configuration in your particular solution.\n\n## 3.3 Session Affinity\n\nTLS connection setup is a costly CPU operation. It is therefore important to ensure that routing components are configured for session affinity to avoid unnecessary connection setup costs. Clients should be written to reuse connections when making multiple requests.\n\n## 3.4 Value-Id Caches\n\nThe IBM FHIR Server uses internal memory caches for resource type names, parameter names, references, codes and systems. These caches use a least-recently-used (LRU) strategy to avoid unbound growth which would result in an out-of-memory (OOM) condition.\n\nCurrently the IBM FHIR Servers do not use sharding(*) to distribute client requests and so any client request may hit any server in a given cluster. This means that the memory used for caching value-id lookups is not distributed, but each servers' cache is complete and may contain data also cached in another server. This may be revised in future releases if it becomes a scaling issue.\n\n(*) - sharding is really the responsibility of the component used to route requests to the IBM FHIR Servers, and if such a component were to support sharding, it would help to reduce the cache pressure by distributing values among the available cache instances.\n\nThe following datasource properties in fhir-server-config.json are used to tune the size of the value-id caches:\n\n\n| Property                | Default Value | Units           | Description |\n| ----------------------- | ------------- | --------------- | ----------- |\n| externalSystemCacheSize |          1000 | Number of items | Size of the LRU cache used to hold unique code-system values. Per tenant/datastore. |\n| externalValueCacheSize  |        100000 | Number of items | Size of the LRU cache used to hold unique token values. Per tenant/datastore. |\n\n\nThe caches are isolated by tenant and specific to each datasource defined for that tenant:\n\n```\n{\n    \"fhirServer\": {\n        \"persistence\": {\n            \"factoryClassname\": \"com.ibm.fhir.persistence.jdbc.FHIRPersistenceJDBCFactory\",\n            \"common\": {\n                \"__comment\": \"Configuration properties common to all persistence layer implementations\",\n                \"updateCreateEnabled\": true\n            },\n            \"jdbc\": {\n                ...\n                \"enableCodeSystemsCache\": true,\n                \"enableParameterNamesCache\": true,\n                \"enableResourceTypesCache\": true\n            },\n            \"datasources\": {\n                \"default\": {\n                    \"jndiName\": \"jdbc/bootstrap_default_default\",\n                    \"type\": \"derby\",\n                    \"currentSchema\": \"APP\",\n                    \"externalSystemCacheSize\": 1000,\n                    \"externalValueCacheSize\": 100000\n                },\n                ...\n            }\n        }\n    }\n}\n```\n\nCurrently no cache-hit metrics are exposed related to the caches. Tuning relies on Application Performance Management (APM) profiling and monitoring database activity looking for frequent value-id lookups against the following tables:\n\n* PARAMETER_NAMES\n* RESOURCE_TYPES\n* COMMON_TOKEN_VALUES\n* CODE_SYSTEMS\n\nThe values for PARAMETER_NAMES and RESOURCE_TYPES are supposed to be fully cached. Any substantial reads (selects) from these tables after initial startup/first request should be considered a defect.\n\n## 3.5 Logical Id Generation\n\nUsing random values for resource identifiers can cause performance issues in large databases. This is a particular issue when using PostgreSQL with the IBM FHIR Server due to an issue known as write amplification from full page writes. For details, see this blog post: https://www.2ndquadrant.com/en/blog/on-the-impact-of-full-page-writes.\n\nFor best performance, ids generated by clients should not be purely random but instead be structured to include a prefix which increments over time. This causes index entries for new values to share pages (right-hand inserts), greatly reducing the write amplification overhead.\n\nOne example of a suitable id generation strategy can be found in the [IBM FHIR Server fhir-persistence-jdbc project](https://github.com/IBM/FHIR/blob/main/fhir-persistence-jdbc/src/main/java/com/ibm/fhir/persistence/jdbc/util/TimestampPrefixedUUID.java).\n\nThis strategy provides both the desirable trait of global uniqueness as well as a low write amplification overhead thanks to the time-based prefix.\n\nThe IBM FHIR Server also uses normalization to avoid storing (and indexing) long identifier strings in multiple places. This saves space, and the database-generated identity values are based on sequences which naturally produce the desired right-hand-insert behavior.\n\n## 3.6 Compartment Search Optimization\n\nResources are assigned to various compartments using expressions with multiple terms. In the IBM FHIR Server JDBC persistence layer, these expressions are translated to SQL predicates with multiple `OR` statements. These `ORs` make it more difficult for the query optimizer to compute the most efficient execution plan resulting in a slow query. To address this, the IBM FHIR Server evaluates the compartment membership expression during ingestion and stores the results. The SQL query can then be written using a single value predicate resulting in faster query.\n\nTo enable this optimization, set the `fhirServer/search/useStoredCompartmentParam` configuration parameter to `true` in the fhir-server-config.json file:\n\n```\n        \"search\": {\n            \"useStoredCompartmentParam\": true\n        },\n```\n\nEnabling this optimization is recommended. See the IBM FHIR Server release notes for more details.\n\n\n# 4 Database Tuning\n\n| Tuneable | Guidance |\n| -------- | -------- |\n| Caching  | Avoiding physical reads is important for most database applications and the IBM FHIR Server is no different. Memory sizing and configuration is important for good ingestion performance as well as good read performance. |\n| Statistics | Ensure statistics are up-to-date to allow the query optimizer to generate the best execution plans. |\n| Concurrency | Ensure the database supports the required number of connections from the application server cluster, plus any administration overhead. Connections and their associated sessions consume memory which must be considered in the overall database server memory budget. |\n\n\n## 4.1 PostgreSQL\n\nFor PostgreSQL, we recommend tuning the following properties:\n\n| Property | Recommendation | Description |\n| -------- | -------------- | ----------- |\n| max_connections | N+15 | N is the aggregate number of connections from the IBM FHIR Server cluster, defined by the connection manager's `maxPoolSize` property. Check the PostgreSQL documentation. Connections require memory, so be careful with large values which could lead to memory pressure on the database server causing performance issues or stability problems. |\n| shared_buffers | 1/2 of memory | The number of 8kB blocks used for caching table data. This is important for ingestion as well as query performance. The database must be able to find free blocks to hold table and index data it needs to modify when ingesting new data. |\n| effective_cache_size | 3/4 of memory | Number of 8kB blocks. Not an allocation, just provides guidance to the query optimizer for how much data it can expect to be cached by the database and operating system file system cache. It is used to bias decisions on choosing index-based access paths. IBM FHIR Server queries rely heavily on index-driven plans so this value should be at the upper end of any recommended range. |\n\nThe recommended values should be considered a starting point. Monitor database metrics and tune appropriately for your given workload. See the [PostgreSQL wiki](https://wiki.postgresql.org/wiki/Tuning_Your_PostgreSQL_Server) for additional guidance.\n\nFHIR search queries are translated into SQL expressions. When several search parameters are included in a request the resulting join spans many tables, several of which may be wrapped in views. In order to give the PostgreSQL query optimizer sufficient freedom to optimize the query, include the `searchOptimizerOptions` parameter map to the datasource configuration as shown below to increase the values for `from_collapse_limit` and `join_collapse_limit`. The default for both of these is 8. When there are more than 8 tables involved in the search query, the optimizer may not generate an efficient execution plan unless the limits are increased:\n\n```\n        \"persistence\": {\n            \"datasources\": {\n                \"default\": {\n                    \"type\": \"postgresql\",\n                    \"currentSchema\": \"fhirdata\",\n                    \"searchOptimizerOptions\": {\n                        \"from_collapse_limit\": 16,\n                        \"join_collapse_limit\": 16\n                    },\n                    ...\n```\n\nSee the [PostgreSQL Query Planning](https://www.postgresql.org/docs/12/runtime-config-query.html) guide for more information.\n\n### 4.1.1 Fillfactor\n\nIn PostgreSQL, the default `fillfactor` for each table is 100 - no room is reserved for updates. This maximizes storage utilization, but impacts performance for updates which occur when new versions of a resource are ingested. Update statements are also used frequently during the reindex process.\n\nTo provide space for updates, all the `<resourceType>_logical_resources` should be configured with a `fillfactor` of 80 as a starting point. DBAs may specify their own `fillfactor` values based on their own knowledge and understanding of the system.\n\nThe `fillfactor` for the `logical_resources` table may benefit from an even lower value to support the heavy update load during a reindex operation. This is a special case due to the fact that every row in the table is updated once.\n\nTo change the fillfactor for existing data, a `VACUUM FULL` operation is required:\n\n```\nALTER TABLE fhirdata.logical_resources SET (fillfactor=70);\n...\nVACUUM FULL fhirdata.logical_resources;\n```\n\nThis should only be performed during a maintenance window when there is no load on the system.\n\n### 4.1.2 Tuning Auto-vacuum\n\nWhen running reindex operations (after a search parameter configuration change, for example), the `logical_resources` table undergoes frequent updates to an indexed column. Due to the nature of how PostgreSQL handles updates, this results in a significant amount of old index blocks which slows progress. The table storage parameters may need to be tuned to vacuum the `logical_resources` table more aggressively. To address this, tune the storage parameters for this table as follows:\n\n```\n-- Lower the trigger threshold for starting work\nalter table fhirdata.logical_resources SET (autovacuum_vacuum_scale_factor = 0.01, autovacuum_vacuum_threshold=1000);\n\n-- Increase the amount of work vacuuming completes before taking a breather (default is typically 200)\nalter table fhirdata.logical_resources SET (autovacuum_vacuum_cost_limit=2000);\n```\n\nThe default value for autovacuum_vacuum_cost_limit is likely too restrictive for a system with good IO performance. Increasing the value to 2000 increases the throttling threshold 10x, significantly improving throughput and helping the `logical_resources` vacuuming to be completed before it negatively impacts reindexing performance.\n\nSee the [PostSQL VACUUM documentation](https://www.postgresql.org/docs/12/sql-vacuum.html) for more details.\n\nIn addition, administrators may also choose to run a manual vacuum as shown in the following example:\n\n```\nfhirdb=> VACUUM (ANALYZE,VERBOSE) fhirdata.logical_resources;\nINFO:  vacuuming \"fhirdata.logical_resources\"\nINFO:  scanned index \"logical_resources_pk\" to remove 16813312 row versions\nDETAIL:  CPU: user: 31.70 s, system: 14.30 s, elapsed: 75.38 s\n\nINFO:  scanned index \"unq_logical_resources\" to remove 16813312 row versions\nDETAIL:  CPU: user: 70.03 s, system: 56.69 s, elapsed: 232.57 s\nINFO:  scanned index \"idx_logical_resources_rits\" to remove 16813312 row versions\nDETAIL:  CPU: user: 11.42 s, system: 14.00 s, elapsed: 45.40 s\nINFO:  \"logical_resources\": removed 16813312 row versions in 355153 pages\nDETAIL:  CPU: user: 27.36 s, system: 12.08 s, elapsed: 67.53 s\nINFO:  index \"logical_resources_pk\" now contains 77504219 row versions in 544383 pages\nDETAIL:  16806938 index row versions were removed.\n0 index pages have been deleted, 0 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  index \"unq_logical_resources\" now contains 77504219 row versions in 2393179 pages\nDETAIL:  16805676 index row versions were removed.\n0 index pages have been deleted, 0 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  index \"idx_logical_resources_rits\" now contains 77504219 row versions in 775877 pages\nDETAIL:  16813298 index row versions were removed.\n507613 index pages have been deleted, 445589 are currently reusable.\nCPU: user: 0.00 s, system: 0.00 s, elapsed: 0.00 s.\nINFO:  \"logical_resources\": found 7765149 removable, 16804352 nonremovable row versions in 549284 out of 4210218 pages\nDETAIL:  0 dead row versions cannot be removed yet, oldest xmin: 320896669\nThere were 21857963 unused item identifiers.\nSkipped 0 pages due to buffer pins, 3070111 frozen pages.\n46 pages are entirely empty.\nCPU: user: 206.67 s, system: 113.27 s, elapsed: 537.14 s.\nINFO:  analyzing \"fhirdata.logical_resources\"\nINFO:  \"logical_resources\": scanned 30000 of 4210218 pages, containing 551774 live rows and 0 dead rows; 30000 rows in sample, 77436294 estimated total rows\nVACUUM\n```\n\n### 4.1.3 Transaction Id Wraparound\n\nBe ware of multixact wraparound issues, as highlighted by the following warning when running a manual vacuum:\n\n```fhirdb=> VACUUM (VERBOSE) fhirdata.logical_resources;\nWARNING:  oldest multixact is far in the past\nHINT:  Close open transactions with multixacts soon to avoid wraparound problems.\n```\n\nThis indicates that the automatic vacuum process needs to be more aggressive. See [here](https://info.crunchydata.com/blog/managing-transaction-id-wraparound-in-postgresql) for details.\n\n\n### 4.1.4 Vacuum Monitoring\n\nUse the following query to see the impact of updates and deletes on the IBM FHIR Server tables (assuming the tenant is configured to use the `fhirdata` schema):\n\n```\n SELECT relname,\n        n_tup_ins AS \"inserts\",\n        n_tup_upd AS \"updates\",\n        n_tup_del AS \"deletes\",\n        n_live_tup AS \"live_tuples\",\n        n_dead_tup AS \"dead_tuples\"\n   FROM pg_stat_user_tables\n  WHERE schemaname = 'fhirdata'\n    AND (relname = 'logical_resources' OR relname LIKE '%_values')\n    AND n_dead_tup > 0;\n```\n\nThe values reported are since the database was last restarted. To check uptime, run the following query:\n\n```\n SELECT current_timestamp - pg_postmaster_start_time();\n    ?column?     \n-----------------\n 05:45:41.835965\n```\n\n\nThe following query can be used to see how many auto-vacuum jobs are currently in progress and for which tables:\n\n```\nfhirdb=> SELECT r.relname, v.*\n           FROM pg_stat_progress_vacuum v,\n                pg_stat_user_tables r\n          WHERE r.relid = v.relid;\n\n          relname          |  pid   | datid | datname | relid |       phase       | heap_blks_total | heap_blks_scanned | heap_blks_vacuumed | index_vacuum_count | max_dead_tuples | num_dead_tuples\n---------------------------+--------+-------+---------+-------+-------------------+-----------------+-------------------+--------------------+--------------------+-----------------+-----------------\n imagingstudy_token_values | 451383 | 16478 | fhirdb  | 45603 | vacuuming indexes |          332918 |            332918 |                  0 |                  0 |        96879138 |            5102\n condition_token_values    | 451793 | 16478 | fhirdb  | 52193 | scanning heap     |           53883 |             18173 |                  0 |                  0 |        15679953 |          301285\n logical_resources         | 451180 | 16478 | fhirdb  | 16533 | vacuuming indexes |         1432256 |           1432256 |                  0 |                  0 |       178956970 |          765313\n```\n\nBy default, only 3 vacuum jobs can run concurrently.\n\n### 4.1.5 Max Locks\n\nTo drop an IBM FHIR Server schema in PostgreSQL, set the following configuration in `postgresql.conf`:\n\n```\nmax_locks_per_transaction = 128\t\t# min 10\n```\n\nThis change requires a database restart.\n\n## 4.2 IBM Db2\n\nTBD.\n\n\n## 4.3 Derby\n\nDerby is not recommended for production use and therefore tuning Derby will not be addressed in this guide.\n\n\n# 5 Client Access Scenarios\n\nThe IBM FHIR Server translates a FHIR search request into a SQL query. The database performs query optimization to generate what it thinks is the most efficient execution plan before running the query. This optimization depends on the database having good statistics (and a clever algorithm) to make the right choice. When this goes wrong, the result is a slow response which can also end up consuming significant resources which impact the capacity of the system as a whole.\n\nThe FHIR search specification includes a rich set of capabilities designed to make it easier for clients to find data. If a particular search performs poorly, there are likely other ways the same data can be fetched. One solution is to use multiple requests, using FHIR bundle requests to request multiple resources in one server request.\n\nThere are many ways to retrieve data:\n\n* READ: read the latest version of a resource using its logical identifier. Fast.\n* VREAD: reads a specific version of a resource using its logical identifier and version. Fast.\n* SEARCH: id - fetch one resource matching the given logical id:\n* SEARCH: identity - fetch all resources matching the given identity. Usually one but could be multiple\n* SEARCH: last-modified - Find resources modified since a given date.\n* SEARCH: multiple attributes - find resources matching the search condition. Can be slow depending on the complexity of the resulting database query and the relative cardinality (row counts) of the resource search parameters.\n* SEARCH: include - fetch additional resources based on the relationships found in the resources returned by the main search criteria.\n* SEARCH - has\n* SEARCH - revinclude\n\nThere may also be some subtle semantic differences among searches which might appear to be equivalent. This is particularly true for compartment-based queries due to the complex definition of compartment membership defined in the FHIR specification.\n\n## 5.1 Read\n\nLogical id-based read requests are the fastest way to access a resource, for example:\n\n```\n    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\n```\n\nThis translates into a single query which utilizes indexes to quickly locate the required record:\n\n```\nSELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID,\n       R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID\n  FROM Patient_RESOURCES R,\n       Patient_LOGICAL_RESOURCES LR\n WHERE LR.LOGICAL_ID = ?\n   AND R.RESOURCE_ID = LR.CURRENT_RESOURCE_ID\n```\n\nWhen the data is currently cached by the database, this query takes less than a millisecond to execute, as shown in the following execution plan analysis from PostgreSQL:\n\n```\nNested Loop  (cost=0.84..10.88 rows=1 width=1335) (actual time=0.046..0.058 rows=1 loops=1)\n  Buffers: shared hit=8\n  ->  Index Scan using idx_patient_logical_resourceslogical_id on patient_logical_resources lr  (cost=0.42..5.44 rows=1 width=53) (actual time=0.026..0.030 rows=1 loops=1)\n        Index Cond: ((logical_id)::text = '17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e'::text)\n        Buffers: shared hit=4\n  ->  Index Scan using patient_resources_prf_in1 on patient_resources r  (cost=0.42..5.44 rows=1 width=1290) (actual time=0.011..0.012 rows=1 loops=1)\n        Index Cond: (resource_id = lr.current_resource_id)\n        Buffers: shared hit=4\nPlanning Time: 0.313 ms\nExecution Time: 0.127 ms\n```\n\n## 5.2 Version Read\n\nThe FHIR specification supports reading a specific version of a resource:\n\n```\nPatient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/_history/1\n```\n\nThe resulting query is similar, except in this case, the specified version is requested from the PATIENT_RESOURCES table. Performance is similar to the plain read, depending on what data is currently cached, of course:\n\n```\nSELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID,\n       R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID\n  FROM Patient_RESOURCES R, Patient_LOGICAL_RESOURCES LR\n WHERE LR.LOGICAL_ID = ?\n   AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\n   AND R.VERSION_ID = ?\n```\n\n## 5.3 History\n\nThe history query returns all versions of a resource. Because there is no limit to the number of versions for a given resource, the results are ordered by the version_id (resource version number) and paginated using OFFSET and FETCH NEXT ROWS clauses:\n\n```\n  SELECT R.RESOURCE_ID, R.LOGICAL_RESOURCE_ID, R.VERSION_ID,\n         R.LAST_UPDATED, R.IS_DELETED, R.DATA, LR.LOGICAL_ID\n    FROM Patient_RESOURCES R, Patient_LOGICAL_RESOURCES LR\n   WHERE LR.LOGICAL_ID = ?\n     AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID\nORDER BY R.VERSION_ID DESC\n  OFFSET ? ROWS\n  FETCH NEXT ? ROWS ONLY\n```\n\nIn order to include an overall count of the number of resource versions, the IBM FHIR Server must execute an additional SQL query:\n\n```\nSELECT COUNT(R.VERSION_ID)\n  FROM Patient_RESOURCES R,\n       Patient_LOGICAL_RESOURCES LR\n WHERE LR.LOGICAL_ID = ?\n   AND R.LOGICAL_RESOURCE_ID = LR.LOGICAL_RESOURCE_ID;\n```\n\nIn most cases the history queries will execute very quickly. Performance will be slower for cases where a single resource has thousands of versions. To avoid this, ingestion pipelines must ensure they only update a version when necessary.\n\n## 5.4 Search Performance\n\n**Predicate Order**\n\nThe IBM FHIR Server translates FHIR search queries into SQL statements which may require many tables to be joined. The database attempts to optimize the query execution plan by analyzing join conditions, filter predicates, available indexes and column statistics. The optimizer also attempts to order the joins in order to reduce the amount of work it must do. This usually involves computing the most selective clauses first. When there are many tables involved, the database optimizer may not always find the most efficient execution plan which can result in higher response times or `500` server errors if the total time exceeds the transaction timeout limit. For example, on a large database the following query may perform poorly if there are many ExplanationOfBenefit records with a Claim matching one of the given priorities:\n\n```\n/ExplanationOfBenefit?_pretty=true&claim.priority=normal,stat,deferred&_include=ExplanationOfBenefit:claim&_include=ExplanationOfBenefit:patient&patient:Patient.birthdate=le1915\n```\n\nThe above query requires a join of around 13 tables which is too many for the database to try all possible orders and so the most efficient plan is never tried. The IBM FHIR Server builds the SQL based on the order of filter predicates in the search request. This can be used along with knowledge of the data to place the most selective filter first which, in this case, is the patient `birthdate` range. Rewriting the query as follows can significantly improve the response time:\n\n```\n/ExplanationOfBenefit?_pretty=true&patient:Patient.birthdate=le1915&claim.priority=normal,stat,deferred&_include=ExplanationOfBenefit:claim&_include=ExplanationOfBenefit:patient\n```\n\n**Include Code System**\n\nToken-based searches should include a code-system when possible. The same code value might exist in multiple code-systems, Unless the code-system is included in the search query, the database join may need to consider multiple matches in order to find all the associated resources. This multiplies the amount of work the database must do to execute the query. This also impacts cardinality estimation by the optimizer. If both the code-system and code value are provided, this matches a unique index in the schema allowing the optimizer to infer the SQL fragment will produce a single row.\n\nDon't do this:\n```\nPatient/175517d8bea-32d33eec-d98f-4c99-a3cf-06a113ddcf08/CareTeam?status=active\n```\n\nInstead, do this:\n```\nPatient/175517d8bea-32d33eec-d98f-4c99-a3cf-06a113ddcf08/CareTeam?status=http://hl7.org/fhir/care-team-status|active\n```\n\nExplicitly providing the code is always preferred. If no system is provided, in some cases the IBM FHIR Server can determine the correct code-system to use automatically, which helps query performance.\n\n\n## 5.5 Search Examples\n\nThe section contains search examples and performance considerations for various types of search parameters.\n\n**STRING SEARCH**\nBecause the default behavior for string search has case-insensitive \"begins-with\" semantics, we encourage users to use the `:exact` modifier when possible for the best performance.\n\n**TOKEN SEARCH**\nHL7 FHIR supports a few variants of token search:\n* `[parameter]=[code]`\n* `[parameter]=[system]|[code]`\n* `[parameter]=|[code]`\n\nFor optimal performance, users should prefer the `[system]|[code]` variant.\n\nThis is especially important for code values that are common across systems (e.g short strings like \"active\").\nHowever, the IBM FHIR Server supports a SearchParameter extension which allows the server to add an implicit `[system]|` prefix for certain token parameter searches that come in with just a `[code]`.\n\nFor example, when a search parameter targets an element of type Code that has a required binding, there is typically a single implicit system for the code. In such cases, the IBM FHIR Server models these Code subtypes as Enums and the values are indexed with their implicit system. When the corresponding SearchParameter definition is decorated with the same implicit system (via this extension), it provides maximum specificity for the query to efficiently retrieve the token value.\n\nFor all such search parameters in the base spec, and first-class implementation guides that we package, we have taken the liberty to add these extensions a priori. For example, for `SearchParameter-Account-status`, the following extension tells the server to process a query like `Account?status=active` as if it were specified like `Account?status=http://hl7.org/fhir/audit-event-outcome|active`:\n```\n{\n    \"url\": \"http://ibm.com/fhir/extension/implicit-system\",\n    \"valueUri\": \"http://hl7.org/fhir/audit-event-outcome\"\n}\n```\n\n**COMPARTMENT SEARCHES**\n\nSearch for all ExplanationOfBenefit records which reference the patient according to its logical id `17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e`.\n\n```\n    <base>/ExplanationOfBenefit?patient=17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\n```\n\n\nSearch the patient compartment `17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e` for all matching ExplanationOfBenefit resources.\n\n```\n    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/ExplanationOfBenefit\n```\n\n**COMPARTMENT CHAINED SEARCH**\n\nRequests any ExplanationOfBenefit resources belonging to the compartment for patient `17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e` with a Claim created on a given day: 2015-10-16.\n\n```\n    <base>/Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e/ExplanationOfBenefit?claim:Claim.created=2015-10-16\n```\n\n**CLIENT SEARCH BUNDLES**\n\nIf the response time is not acceptable, an alternative strategy is to first fetch all the ExplanationOfBenefit resources associated with the given patient, then compose a second bundle request for the Claim records associated with the ExplanationOfBenefit resources returned by the first search. The initial request can fetch the Patient resource along with the ExplanationOfBenefit resources for that patient.\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Patient/17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"ExplanationOfBenefit?patient=17546b5cd4a-cae29bb0-d6d7-4a1a-a8df-505e2e3a975e\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\nNote the bundle type is specified as `transaction`. Because all the entries in the bundle are reads, there's no modification to the database and so no semantic difference between using `transaction` or `batch`. However, for `transaction`, the IBM FHIR Server initiates a single transaction for the entire request. In high load/concurrency conditions, this improves throughput.\n\nThe number of ExplanationOfBenefit resources for a given patient is likely to be relatively small. By iterating over the response to the previous request, the client can package a number of resource reads into one or more bundle requests. Read requests are the most efficient type of request for accessing data from the IBM FHIR Server.\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim/1747d7abed3-7f331c1b-5262-41b7-894a-09d63ddc1791\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7abe89-61ad12fd-61ba-4c06-9fbf-89a130babd27\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim/1747d7abf2d-bbfd621f-31ec-4044-88df-a5d14efba26a\"\n            }\n        },\n        ...\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7ac6b2-90d24ffc-b773-45c0-8194-a24057087c82\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\nAlthough this approach involves multiple requests to the IBM FHIR Server, the overall response time may be quicker due to the simplicity of the requests.\n\nThe client can filter the required Claim resources, or alternatively convert the reads to search requests:\n\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim?_id=1747d7abed3-7f331c1b-5262-41b7-894a-09d63ddc1791&created=2015-10-16\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7abe89-61ad12fd-61ba-4c06-9fbf-89a130babd27\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim?_id=1747d7abf2d-bbfd621f-31ec-4044-88df-a5d14efba26a&created=2015-10-16\"\n            }\n        },\n        ...\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner/1747d7ac6b2-90d24ffc-b773-45c0-8194-a24057087c82\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\n**INCLUDE**\n\nAnother alternative which tends to perform well uses the `_include` function. The `_include` function is useful because it avoids the need for additional round-trips (the server performs the iteration internally).\n\nThis example retrieves ExplanationOfBenefit resources for patient `17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756` which were created between 2010 and 2020. The result bundle also includes the Patient, Provider, CareTeam and Coverage resources referenced by each matching ExplanationOfBenefit resource.\n\n```\n    <base>/ExplanationOfBenefit?patient=Patient/17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756&created=ge2010&created=lt2021&_include=ExplanationOfBenefit:patient&_include=ExplanationOfBenefit:provider&_include=ExplanationOfBenefit:care-team&_include=ExplanationOfBenefit:coverage\n```\n\n\n**REVINCLUDE**\n\nUsed when a client wants a particular resource and other resources pointing to it. For example, to retrieve a Patient resource and any Observations referring to that patient as the subject:\n\n```\n    <base>/Patient?_id=17478598887-c1279929-f2ca-48e5-815a-b812bfc2e756&_revinclude=Observation.subject\n```\n\nFind all Observations matching the composite code-value-quantity value and for each such Observation, also return any DiagnosticReport referring to that Observation as the result:\n\n```\n    <base>/Observation?code-value-quantity=http://loinc.org|2339-0$69.1&_revinclude=DiagnosticReport:result\n```\n\nThe above query is likely to be expensive if the number of matching Observations is high. For better performance, consider constraining the search with additional predicates like the patient id.\n\n\n**LAST UPDATED**\n\nSearching for all resources updated on a single day is expensive:\n\n```\n    <base>?_lastUpdated=2020-10-31\n```\n\nIf possible, limit the search to a specific resource type. For example:\n\n```\n    <base>/Patient?_lastUpdated=2020-10-31\n```\n\nIf multiple resource types are of interest, consider packaging multiple search requests into a bundle:\n\n```\n{\n    \"entry\": [\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Patient?_lastUpdated=2020-10-31\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Claim?_lastUpdated=2020-10-31\"\n            }\n        },\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"Practitioner?_lastUpdated=2020-10-31\"\n            }\n        },\n        ...\n        {\n            \"request\": {\n                \"method\": \"GET\",\n                \"url\": \"ExplanationOfBenefit?_lastUpdated=2020-10-31\"\n            }\n        }\n    ],\n    \"resourceType\": \"Bundle\",\n    \"type\": \"transaction\"\n}\n```\n\n**RESOURCE SUBSETTING**\n\nHL7 FHIR defines return parameters `_summary` and `_elements` for requesting the server to subset the resources to be returned via search.\n\nThe IBM FHIR server implements such element filtering directly in its resource parser, meaning that the feature can save time in the parse as well as reducing the size of the response to the client.\n\nThis can provide significant savings for search requests that bring back lots of data (large pages and/or many field per resource).\n\n## 6 Tools\n\n## 6.1 Making FHIR Requests With curl\n\n```\ncurl -k -i \\\n-H 'Content-Type: application/json' \\\n-H 'X-FHIR-TENANT-ID: default' \\\n-u 'fhiruser:change-password' 'https://localhost:9443/fhir-server/api/v4/Practitioner/1749321b933-9fd77253-7fd4-47db-8ff8-9e4ccb21441d'\n```\n\nNote that the tenant header must match the tenant header defined in the fhir-server-config.json. The default tenant header is `X-FHIR-TENANT-ID`. If this header is not provided, the tenant value will be `default`.\n\nThe curl command can also be used to make POST calls to the IBM FHIR Server. This example creates a new Observation resource for the patient subject `abc123`:\n\n```\ncurl -k -i \\\n-H 'Content-Type: application/json' \\\n-H 'X-FHIR-TENANT-ID: default' \\\n-u 'fhiruser:change-password' 'https://localhost:9443/fhir-server/api/v4/Observation' -d '\n{\n    \"resourceType\": \"Observation\",\n    \"subject\": {\n        \"reference\": \"Patient/abc123\"\n    },\n    \"status\": \"final\",\n    \"code\": {\n        \"coding\": [{\n            \"system\": \"http://snomed.info/sct\",\n            \"code\": \"363779003\",\n            \"display\": \"Genotype determination\"\n        }],\n        \"text\": \"Diplotype Call\"\n    },\n\"text\": {\n    \"status\": \"generated\",\n    \"div\": \"__redacted for brevity__\"\n  }\n}\n'\n```\n\nExamples of valid resources can be found in the [fhir-examples](https://github.com/IBM/FHIR/tree/main/fhir-examples) project.\n\n\n\n## 6.2 Making FHIR Requests with IBM FHIR Server Client\n\nSee FHIR client API in the [IBM FHIR Server User's Guide](https://ibm.github.io/FHIR/guides/FHIRServerUsersGuide).\n","fileAbsolutePath":"/home/runner/work/FHIR/FHIR/fhir/docs/src/pages/guides/FHIRPerformanceGuide.md","fields":{"slug":"/guides/FHIRPerformanceGuide"}}}},"staticQueryHashes":["1364590287","2102389209","2102389209","227138135","227138135","2456312558","2746626797","2746626797","3018647132","3018647132","3906363820","3906363820","768070550"]}